% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_separation.R
\name{test.separation}
\alias{test.separation}
\alias{test.sep}
\title{Detect Separation}
\usage{
test.separation (object, ...)

## S3 method for class 'formula'
test.separation (object, binary = TRUE, data = environment(formula(object)),
                 weights, subset, na.action = stats::na.omit, offset = NULL,
                 contrasts = NULL, sanitize = TRUE, epsilon = 1e-04,
                 method = "iterative_rectifier", maxit = 500, ...)

## S3 method for class 'glm'
test.separation (object, data = object$data, subset = NULL,
                 na.action = stats::na.omit, sanitize = TRUE,
                 epsilon = 1e-04, method = "iterative_rectifier",
                 maxit = 500, ...)

## Routine for prepared response vector 'y' and design matrix 'x'
test.sep (y, x, weights = 1, offset = 0, binary = TRUE, epsilon = 1e-08,
          method = "iterative_rectifier", maxit = 500, ...)
}
\arguments{
\item{object}{an object of a class with a \code{test.separation} method,
or for the default metjod, a numeric vector representing the dependent
variable in a Generalized Linear Model (GLM) framework.}

\item{...}{further arguments passed to or from other methods.
Currently not used.}

\item{data, weights, subset, na.action, offset, contrasts}{same as for
\link[stats]{glm}.

Currently, the only available \code{method} does not handle missing values.
Accordingly, the argument \code{na.action} should always be left as
\code{na.action = na.omit}.

Argument \code{weights} is currently used only when \code{binary = TRUE}.
Otherwise, it is ignored by the currently available method.
Argument \code{offset} is currently not used at all.}

\item{epsilon}{small positive real in the open \eqn{(0, 1)}, tolerance for
the convergence of residuals to zero. Defaults to \eqn{10^{-4}}.}

\item{method}{character indicating the separation detection algorithm to
be used. Currently, only \code{"iterative_rectifier"} (also \code{'ir'})
is available.}

\item{maxit}{integer, maximum number of iterations allowed.}

\item{x, y}{numeric matrix/vector, i.e. \code{x} is a design
matrix of dimension \code{n * p}; and \code{y} is a vector of observations
of length \code{n}.}

\item{binary}{logical, should the response in \code{formula} or \code{y}
be considered as a binomial response? Defaults to \code{TRUE}.}

\item{sanitize}{logical, should columns corresponding to aliased
coefficients and rows corresponding to missing observations (with
\link{NA}s) be removed from the design matrix? Defaults to \code{TRUE}.}
}
\value{
a logical scalar, indicating separation.

The returned value has the following attributes:

\item{\code{convergence}}{ a named vector of information from the used
algorithm:}
\itemize{
\item \emph{converged}, a binary scalar, did the algorithm converge?
\item \emph{niter}, the number of iterations used by the employed algorithm;
}

\item{\code{separated}}{ \code{NULL}, or an integer vector indicating
which observations (if any) are separated by the response;}
\item{\code{aliased}}{ \code{NULL}, or integer vector indicating columns of
the design matrix \code{x} with aliased coefficients (these columns are
removed before any separation related calculation, leading
to a non-singular reduced design matrix, used for the subsequent
separation analysis);}
\item{\code{resid}}{ a named vector of additional information on the
achieved convergence threshold, i.e. the absolute values of iterated
weighted least-square residuals:}

\itemize{
\item \emph{min}, the observed minimum of the absolute residuals;
\item \emph{max}, the observed maximum of the absolute residuals
(convergence is determined by \code{max < epsilon});
}

\item{\code{epsilon}}{ the used tolerance argument.}

Note that the attribute \code{separated} will be non-null only when
the output is \code{TRUE}, i.e., when there is separation (otherwise,
no observation is separated, and \code{NULL} is returned).
Likewise, the attribute \code{aliased} will be non-null only when
there are aliased columns (linear dependency between columns of the
design matrix).

For the algorithm \code{iterative_rectifier},
when the output has attribute \code{convergence[1] = 1}:

\itemize{
\item a \code{TRUE} output indicates that the response separates the
linear predictor for some non-zero vector of regression coefficients;
\item conversely, a \code{FALSE} output indicates non-separation, i.e.
the maximum likelihood estimates of all regression coefficients are finite.
}

If the output has attribute \code{convergence[1] = 0}, then the
attributes \code{resid} (\emph{min} and \emph{max}) indicate to
what extent the returned result is far from convergence.
}
\description{
Test for data separation in a generalized linear regression model.
}
\details{
\code{test.separation} is a generic function with a default method that
handles a 'numeric' vector \code{object} supplied with a numeric matrix \code{x}.

Complete (or quasi) separation occurs in generalized linear models when one or
more of the independent variables can perfectly predict all (or some) outcomes
\insertCite{albert1984existence}{msbreg}. There a few routines for separation
detection in \code{R} (see e.g. \link[detectseparation]{detect_separation}),
generally based on linear programming algorithms
\insertCite{konis2007linear,albert1984existence}{msbreg}.
So far, the only \code{method} implemented here uses the \code{Iterative Rectifier}
algorithm of \insertCite{zylkin2019verifying;textual}{msbreg} (p. 39).
This is an iterative least squares algorithm that is very fast even in very
high dimensional datasets. As the \link[detectseparation]{detect_separation}
function, the \code{test.separation} routine is a \emph{pre-fit} method,
that is, it does not (need to) estimate the model to detect separation
(presence of infinite maximum likelihood estimates) and identify the separated
observations.

When \code{binary = TRUE} (the default), the binomial model is assumed (no
checking is however performed). In this case, the probit-Poisson transformation is
applied to the data before the algorithm is applied.

When \code{sanitize = TRUE}, sanitation consists of:
\itemize{
\item removal of \link{NA}s by applying \link[stats]{na.omit} to the data
in the response vector (\code{y}) and the design matrix (\code{x}),
after their extraction from the \code{object} argument;
\item removal of \emph{aliased} columns by using \link[base]{qr}
decomposition to find aliased coefficients (see \link[base]{qr.coef}).
As such, separation analysis is conditioned (as it should be) on
\emph{non-singularity} when \code{sanitize = TRUE}.
}

The general user-level routine is \code{test.separation}.

For the advanced user with prepared response vector \code{y} and design
matrix \code{x}, the \code{test.sep} version may be preferred.
The latter is the workhorse of \code{test.separation} for the methods
for classes \code{formula} and \code{'glm'}, may
be substantially faster in large datasets where repeated calls are needed.
}
\examples{
### Basic functioning
# Generate a dataset (binary response
# unrelated to the predictors)
set.seed(10)
df <- data.frame (y = rbinom(15, 1, 0.5),
                  # First continuous predictor
                  x1 = rnorm(15),
                  # Factor with three levels
                  f1 = rep(c('a', 'b', 'c'),
                           length.out = 15))

# Test for separation
test.separation (y ~ x1 + f1, data = df)

}
\references{
\insertAllCited{}
}
\seealso{
See \link[msbreg]{identifiability} to test for the practical
identifiability of model parameters from observed data.
}
