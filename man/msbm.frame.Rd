% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/msbmframe.R
\name{msbm.frame}
\alias{msbm.frame}
\title{Multistage Binomial Model Frame}
\usage{
msbm.frame(
  formula,
  input.me = list(),
  stage.me = NULL,
  alpha.formula = ~0,
  lambda.formula = ~1,
  kappa.formula = ~0,
  data = environment(formula),
  weights = NULL,
  sample.weights = NULL,
  subset = NULL,
  na.action = stats::na.omit,
  drop.unused.levels = FALSE,
  offset,
  frames = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{formula}{an object of class "\link[stats]{formula}" (or one that can
be coerced to that class), a symbolic description of the MSB model.
The details of model specification are given under section \strong{Details}.}

\item{input.me}{optional named list of one sided \link{formula} objects
specifying standard deviations for numerical predictors (variables included
in \code{formula} and that have known standard deviations of measurement
errors). The default (\code{input.me = list()}) assumes no measurement error
in the predictors in the MSB model. If any, columns corresponding to
elements in \code{input.me} are assumed to be non-negative (this is
ensured by passing these columns to \link{abs}).
See section \strong{Details} for specification rules.}

\item{stage.me}{optional one sided \link{formula} object specifying
minimum standard deviations for model stages which have
at least one numerical predictor or an offset. These
standard deviation offsets are added to any standard deviation
implied by \code{input.me} for a given stage.
See section \strong{Details}.}

\item{alpha.formula}{optional one sided \link{formula} object specifying
covariates to be included in the linear predictor for \eqn{\alpha} (parameter
that determines the minimum success probability of the binomial response
variable) in the MSB model. The default behavior assumes that \eqn{\alpha}
is zero.}

\item{lambda.formula}{optional one sided \link{formula} object specifying
covariates to be included in the linear predictor for \eqn{\lambda} (the
maximum success probability of the binomial response) in the MSB model. The
default behavior assumes that the covariate matrix is a constant column of
all ones, that is, \eqn{\lambda} is a constant in \code{(0, 1)}.}

\item{kappa.formula}{optional one sided \link{formula} object specifying
covariates to be included in the linear predictor for a real parameter
that determines the dependence between
the Bernoulli counts that made up each binomial response, applicable when
the number of trials (Bernoulli experiments) is greater than one.
The default behavior assumes that \eqn{\kappa = 1}.

This is a planned feature of the \code{msbreg} package, currently not
implemented. When applicable, specifying \code{kappa.formula} would replace
the usual binomial distribution by a Conway-Maxwell-Binomial distribution (CMB)
\insertCite{kadane2016sums}{msbreg} for log-likelihood calculations, allowing
both positive (\eqn{-\infty < \kappa < 1}) and negative (\eqn{1 < \kappa < \infty})
dependence when modelling binomial counts resulting from multistage designs.
Of course, the CMB distribution is reduced to the binomial distribution
when \eqn{\kappa = 1}.}

\item{data}{a data frame (or object coercible by \link{as.data.frame} to a
data frame), list or environment, containing the variables in \code{formula}.
Neither a matrix nor an array is accepted.}

\item{weights}{an optional vector of \emph{number of trials} ran to obtain the
response specified in \code{formula}. The \code{weights} indicate the
sampling effort corresponding to each data point (row).}

\item{sample.weights}{an optional vector of non-negative real,
indicating how representative each data point is vis-a-vis the
target population (see section \emph{Observation weights} in \strong{Details}).
Should be \code{NULL} or a \code{numeric} vector.}

\item{subset}{a specification of the rows/observations to be used: defaults
to all (see \link[stats]{model.frame} for details).}

\item{na.action}{an optional (name of a) function for treating missing values
which must be coded as \link{NA}s in \code{data} (see \link[stats]{model.frame} for
details).}

\item{drop.unused.levels}{should factors have unused levels dropped?
Defaults to \code{FALSE}.}

\item{offset}{not used, included to prevent the inclusion of an \link{offset}
into the MSB model specification through \code{...}.
See section \emph{Including offsets} in \strong{Details} for the right way to specify
offsets in the MSB model.}

\item{frames}{logical, should the \link[stats]{model.frame}s corresponding to
different model components be returned? Defaults to \code{FALSE}.}

\item{verbose}{integer, should information be printed while building the
model frame? A positive value means yes, and larger value might provide
more details.}

\item{...}{extra arguments for future methods (to pass to or from).
Currently only passed to \link[stats]{model.frame}.}
}
\value{
an object of class \code{"msbm.frame"} which is a
\link[base]{list} with at least the following elements:

\item{\code{y}}{ the binomial response vector;}

\item{\code{weights}}{ the \emph{number of trials} for each binomial response;
If the response was specified by giving a two-column left hand side in
\code{formula}, the weights returned by \code{weights} are the total numbers
of cases (factored by the supplied case \code{weights}) and the component
\code{y} of the result is the corresponding total number of successes;}

\item{\code{sample.weights}}{ the importance of the \emph{population patch}
represented by each observation (row), \code{1} (scalar) if argument \code{sample.weights} is \code{NULL},
or a vector corresponding to the specified importance;}

\item{\code{intercepts}}{ binary vector indicating the presence (\code{1})
or absence (\code{0}) of an intercept in each stage;}

\item{\code{input.matrix}}{ design matrix of all contrasts to be estimated;}

\item{\code{offset.matrix}}{ \code{NULL} or matrix of all offset columns;}

\item{\code{me}}{ logical, does the model include any measurement error (ME)?}

\item{\code{sd.input.matrix}}{ matrix of standard deviations for model contrasts that have MEs;}

\item{\code{me.offset}}{ logical, does any model stage include ME offsets
(i.e. not attached to any contrast)?}

\item{\code{sd.offset.matrix}}{ matrix of standard deviations for model
stages (only stages that have a continuous predictor or an offset are
concerned);}

\item{\code{stage.dictionary}}{ a list of length \code{q} (the number of stages):
the \emph{j}th element gives, for the \emph{j}th stage, the vector of column numbers of
contrasts (in the matrix \code{input.matrix}) included into the stage; the
vector (which can be a zero length \code{integer} vector, provided the stage
has an \code{offset}) has potential attributes:}

\itemize{
\item \code{"order"}: the order of each contrast in the stage,
\item \code{"assign"}: integer vector indicating the model terms each contrast derives from,
\item \code{"intercept"}: \code{1} if there is an intercept term in the stage, \code{0} if not,
\item \code{"offset"}: \code{0} or an \code{offset} vector in the linear predictor for the stage,
\item \code{only.offset}: logical, does the stage only include an offset (no intercept and no predictor)?
\item \code{"has.me"}: logical, does any contrast of the stage has measurement errors (MEs)?
\item \code{"contr.with.me"}: if \code{has.me = TRUE}, index of contrasts that have MEs (if any),
\item \code{"me.index"}: if \code{has.me = TRUE}, column numbers (in the matrix \code{sd.matrix}) of
standard deviations for contrasts that have MEs;
\item \code{"has.me.offset"}: logical, does any stage has measurement error offsets?
\item \code{"me.offset.index"}: if \code{has.me.offset = TRUE}, column numbers
(in the matrix \code{sd.offset.matrix}) of standard deviations for stages
that have MEs;
}

\item{\code{alpha.dictionary}}{ a numeric vector indicating the column
numbers of contrasts (in the matrix \code{input.matrix}) part of
the linear predictor for the \eqn{\alpha} component of the model;}

\item{\code{lambda.dictionary}}{ a numeric vector indicating the column
numbers of contrasts (in the matrix \code{input.matrix}) part of
the linear predictor for the \eqn{\lambda} component of the MSB model;}

\item{\code{kappa.dictionary}}{ a numeric vector indicating the column
numbers of contrasts (in the matrix \code{input.matrix}) part of
the linear predictor for the \eqn{\kappa} component of the MSB model;}

\item{\code{stage.terms}}{ a list of names (\code{names}) and order (\code{order}) of terms per stage;}

\item{\code{auxy}}{ a list of names of terms, covariates, contrasts in the MSB model;}

\item{\code{dims}}{ a list of sizes of different model components, including}

\itemize{
\item \code{nobs}: number of observations in the MSB model (after applying
\code{na.action}),
\item \code{q}: number of stages in the model,
\item \code{npars}: total number of model parameters in the model,
\item \code{p}: total number of intercepts and contrasts in all stages,
\item \code{pi}: total number of intercepts in all stages,
\item \code{pj}: vector of number of contrasts per stage,
\item \code{d}: total number of intercepts and contrasts in \code{alpha.formula},
\item \code{r}: total number of intercepts and contrasts in \code{lambda.formula},
\item \code{s}: total number of intercepts and contrasts in \code{kappa.formula},
\item \code{pt}: total number of terms in all stages,
\item \code{tj}: vector of number of terms per stage,
\item \code{nb_contrasts}: total number of contrasts in the MSB model,
\item \code{nb_covs}: total number of predictors in the model,
\item \code{nb_me.cols}: total number of predictors with MEs in the model;
}

\item{\code{parnames}}{ a character vector, default names for model parameters;}

\item{\code{parindex}}{ a list of four index vectors:}

\itemize{
\item \code{slopes}: vector of positions of regression slopes (coefficients
corresponding to contrasts in \code{formula}, \code{alpha.formula},
\code{lambda.formula}, and \code{kappa.formula}) in \code{parnames} (and
equivalently in the vector of MSB model parameters);

\item \code{intercepts}: vector of positions of intercept coefficients
in \code{parnames};

\item \code{eta.intertcepts}: vector indicating which linear predictors
have intercepts (note that there are \code{q+2} linear predictors in a
MSB model);
}

\item{\code{tables}}{ list of binary tables relating stages, predictors,
terms and contrasts. It includes \code{"stage.contrasts"}, \code{"stage.terms"},
\code{stage.offsets}, \code{"stage.covs"}, \code{"term.contrasts"},
\code{"covs.terms"}, and \code{"me.contrasts"}.

For example, the table \code{tables$stage.contrasts} indicates model stages (rows);
and contrasts (columns) involved in each stage, and the table \code{tables$me.contrasts}
indicates model terms with measurement errors (rows) and contrasts (columns)
containing such terms;}

\item{\code{frames}}{ if requested (\code{frames = TRUE}), a named list
of model frames (result of calling \link[stats]{model.frame}) on
various model components. Except for the component \code{$main} (see
hereafter), the \link[stats]{model.frame}s are obtained before the
application of \code{"na.action"}, if any. The list elements include:}

\itemize{
\item \code{main}: \link[stats]{model.frame} from all terms in
in all input formulas,
\item \code{stages}: list of \link[stats]{model.frame}s
for stages specified in the right hand side of \code{formula},
\item \code{alpha}: \link[stats]{model.frame} from the right hand side of
\code{alpha.formula},
\item \code{lambda}: \link[stats]{model.frame} from the right hand side of
\code{lambda.formula},
\item \code{kappa}: \link[stats]{model.frame} from the right hand side of
\code{kappa.formula},
\item \code{input.me}: list of \link[stats]{model.frame}s from the
right hand sides of \code{formula}s in the input \code{input.me} (a list),
\item \code{stage.me}: \link[stats]{model.frame}s from the right
hand side of the formula input \code{stage.me};
}

\item{\code{call}}{ the matched call to \code{msbm.frame}.}

A \code{"msbm.frame"} class object has the attributes:

\item{\code{na.action}}{ the \link[stats]{na.action} attribute for the design matrices;}

\item{\code{response}}{ a binary scalar indicating the presence (\code{1})
or absence (\code{0}) of a response vector in the model frame.}

Objects of class \code{"msbm.frame"} have a \link[base]{print}
and a \link[base]{summary} methods for a succinct display;
and a \link[stats]{simulate} method to generate pseudo-random
realizations of the response vector given all predictors,
\code{weights}, and a supplied vector of model parameters.
}
\description{
The function provides a \link{formula} interface for specifying a Multistage
Binomial (MSB) model. It builds a \emph{model frame} for a MSB model specified
using a series of \link{formula}s. It calls \link[stats]{model.frame} to
prepare a list of design matrices (containing variables included in input
formulas and any \code{...} arguments) along with a dictionary giving index
vectors for extracting the appropriate design matrix for any MSB model
component.
}
\details{
\strong{Processing}

The function builds a set of design matrices (see section \strong{Value})
for a MSB model. The processing follows that of \link[stats]{model.frame}
which is repeatedly called by \code{msbm.frame}.
Variables in \code{formula}, \code{input.me}, \code{stage.me},
\code{lambda.formula}, \code{alpha.formula}, \code{kappa.formula},
\code{subset} and in \code{...} are looked for in \code{data} (which
is by default the environment \code{msbm.frame} is called from).
The levels of any factor are adjusted according to the
\code{drop.unused.levels} argument.
Following \link[stats]{model.frame}, the \code{subset} expression is evaluated,
and it is used as a row index to various design matrices.
Then the \code{na.action} function is applied to a dataset built with
all variables in \code{formula}, \code{input.me}, \code{stage.me},
\code{lambda.formula}, \code{alpha.formula} and \code{kappa.formula}, what
may add attributes. The resulting \code{NA}-handling action is applied on all
design matrices (which also inherit related attributes, if any).

\strong{Model specification}

The \code{formula} interface is essentially the same as for the
\link{glm} function, except that here, the symbol \code{"|"} is reserved
for delineating different stages in the MSB model.

A typical model specification has the form
\code{response ~ terms.stage.1 | ... | terms.stage.q}
where \code{response} is a binomial response (with
elements in the interval \code{[0, 1]}, interpreted as the
proportion of successful cases) and each element of the list
\code{terms.stage.1, ..., terms.stage.q} is a series of terms
which specifies a linear predictor for a binomial model stage.
When the vector \code{response} contains proportions, multiplication
by \code{weights} (which indicate the total number of cases) must
result in integers (causing an error otherwise).
As for \link[stats]{glm}s, \code{response} can also be a
\link[base]{factor} (where the first level denotes failure
and all others success).
A third alternative format for \code{response} is a two-column
integer matrix with the first column giving the numbers of successes
and the second column the numbers of failures. In this case, the total
number of cases (trials) is the sum of the two columns (times
\code{weights}, if any).

Suppose the binary response variable is named \code{"y"} and the MSB model
has three stages, the first stage having three predictors named \code{"x1"},
\code{"x2"} and \code{"x3"}, the second stage having one predictor
named \code{"z1"}, and the third stage having two predictors named \code{"T1"}
and \code{"T2"}. Then, the model specification reads:

\code{formula = y ~ x1 + x2 + x3 | z1 | T1 + T2}.

Note that an intercept is included by default in each stage.
If a stage does not include an intercept,
it is removed by adding \code{0} as a model term, or using the \code{-}
operator. For instance, to not include an intercept in the first stage
of the above example, we can use:

\code{formula = y ~ 0 + x1 + x2 + x3 | z1 | T1 + T2}

or equivalently

\code{formula = y ~ -1 + x1 + x2 + x3 | z1 | T1 + T2}.

The specification of terms in formulas of linear predictors for
\eqn{\alpha} and \eqn{\lambda} follows the same scheme, but each of these
two formulas must be one-sided.
Suppose \eqn{\lambda} has one predictor named \code{"v1"}.
Then, the model specification will include:

\code{lambda.formula = ~ v1}.

Note that there is no left hand side, i.e. the formula starts with \code{~}.

\strong{Including offsets}

An offset is a term to be added to a linear predictor of the MSB model,
with known coefficient \code{1} rather than an estimated coefficient.

First, be aware that the argument \code{offset} is ignored (not used): it is
included only to prevent its inclusion in the list of \code{...} arguments.
The latter are passed to \link[stats]{model.frame} for each linear predictor
in the model, hence having a general \code{offset} input would be confusing.

Second, to effectively include an offset into any of the linear predictors
in a MSB model, one must use the function \link[stats]{offset}.
For instance, to include an offset named \code{"w1"} into the first
stage of the above three-stage example, a correct specification is:

\code{formula = y ~ offset(w1) + x1 + x2 + x3 | z1 | T1 + T2}.

Since an offset term always has coefficient defined to be \code{1},
there can be more than one offset in a \code{formula}.
All offset terms are simply added to form a unique offset term
to be used for model fitting.
For the same reason, an offset term is always added to the linear predictor
(never subtracted). Hence the specification

\code{formula = y ~ - offset(w1) + x1 + x2 + x3 | z1 | T1 + T2}

is not different from the previous one. To effectively use \code{-w1}
as offset, the correct specification is:

\code{formula = y ~ offset(-w1) + x1 + x2 + x3 | z1 | T1 + T2}

where the minus (\code{-}) sign is included into the call to \link[stats]{offset}.
Finally, offsets can as well be included into \code{alpha.formula}
and \code{lambda.formula}. For instance, if there is a column \code{"wa"}
containing offset values (at link scale) for the maximum success
probability \eqn{\lambda} in the MSB model, we will specify:

\code{lambda.formula = ~ offset(wa) + v1}.

\strong{Observation weights}

The MSB model framework allows two types of weights to be included
during model building:
\code{sample.weights} indicates the percentage of the
target population represented by each data point while
\code{weights} indicates repetitions
within population strata, if any.

In a simple random sampling scheme, each data point represents
\eqn{\frac{1}{n}} of the total population (where \eqn{n} is the
number of data points). This is the default assumption (specified
as \code{sample.weights = NULL}) corresponding to \code{sample.weights}
being a vector of all ones (or any positive constant).

Considering an heterogeneous population, divided into relatively
homogeneous population patches, if random sampling was used within
each stratum (represented as a row in the data), then the number of
Bernoulli trials performed in each stratum will correspond to the
argument \code{weights}, and the importance (e.g. geographical or
demographical weight, area or volume sampled from) of each stratum
relative to the whole population (all strata) will correspond
to the argument \code{sample.weights}.

\strong{Measurement error standard deviations}

Use one-sided formulas to specify columns of standard deviations for
numerical predictors, if any. Suppose that the predictors \code{"x2"} and
\code{"z3"} have measurement errors and their known standard deviations
are in the columns \code{"Erx1"} and \code{"Erz3"}, respectively.
Then, the measurement errors are specified using:

\code{input.me = list(x1 = ~ Erx1, z3 = ~ Erz3)}.

\strong{Standard deviation offsets}

Measurement errors can also be specified for an entire stage.
This is useful when the linear predictor is partially known
for a given stage, and the known part is given as an offset,
but some predictors in the linear predictor offset are
error-prone and the standard deviations (estimates) are known.

\emph{PS}: Only stages, each with a non-null offset or at least
one numeric predictor, can have standard deviation offsets.

The argument \code{stage.me} (which indicates the standard
deviation offsets) follows the same structure as \code{formula}.
When not \code{NULL}, the formula \code{stage.me} must have stages
delineated by the \code{"|"} operator (as in \code{formula}),
following the exact same order of stages in \code{formula}.

When a stage is missing standard deviation offset, the corresponding
slot in \code{stage.me} should have \code{0} as a place
holder (note that using \code{1} as a place holder would imply a
standard deviation offset of \code{1} for the stage).
When the stage missing standard deviation offset \emph{is not} in
the first position, the corresponding slot can be left empty.
If only the first \eqn{m} of the \eqn{q} stages of a MSB model
have standard deviation offsets, then \code{stage.me} can
include only \eqn{m} terms delineated by \code{"|"}s.

For example, let us consider the following model specification:

\code{formula = y ~ offset(w1) + x1 + x2 + x3 | offset(w2) + z1 | T1 + T2}.

Suppose the offset vector \code{offset(w2)} (of the second stage)
has standard deviations in the column \code{Eroff2}.
Then, the measurement errors standard deviation offsets are
specified for the second stage using:

\code{stage.me = ~ 0 | Eroff2},

which is equivalent to

\code{stage.me = ~ 0 | Eroff2 |}.

\emph{PS}: For this particular example, we can rearrange the argument
\code{formula} to further simplify the argument \code{stage.me}
as follows:

\code{formula = y ~ offset(w2) + z1 | offset(w1) + x1 + x2 + x3 | T1 + T2}.

Since the previous stage 2 is now stage 1 which is the only stage with
standard deviation offsets, it suffices to specify

\code{stage.me = ~ Eroff2}.
}
\examples{

# Generate a dataset including a few missing values
# (with a binary response unrelated to the predictors)
set.seed(10)
df <- data.frame(y = c(NA, rbinom(14, 1, 0.5)),
                 # First continuous predictor
                 x1 = c(rnorm(7), NA, rnorm(7)),
                 # known standard deviation of x1
                 SDx1 = c(rexp(7, 1), NA, rexp(7, 1)),
                 # Second continuous predictor
                 x2 = c(rnorm(14), NA),
                 # known standard deviation of x2
                 SDx2 = c(rexp(14, 1), NA),
                 # Numeric, but discrete predictor
                 x3 = rpois(15, 5),
                 # Factor with three levels
                 f1 = rep(c('a', 'b', 'c'),
                          length.out = 15))

# Build and print a MSB model frame with two stages
mframe <- msbm.frame (formula = y ~ x1 + f1| x2 * x3,
                      input.me = list(x1 = ~ SDx1,
                                      x2 = ~ SDx2),
                      data = df)

mframe

}
\references{
\insertAllCited{}
}
\seealso{
See \link[msbreg]{simulate.msbm.frame} for \link[stats]{simulate}
methods for class \code{"msbm.frame"} to generate pseudo-random realizations
of the response vector of a MSB model, given a model frame (\code{"msbm.frame"}
class object) and a vector of model parameters.
Also see \link[msbreg]{msbreg} for fitting MSB regression models.
}
