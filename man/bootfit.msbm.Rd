% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootfit.msbm.R
\name{bootfit.msbm}
\alias{bootfit.msbm}
\title{Bootstrap a Multistage Binomial Model Fit}
\usage{
\method{bootfit}{msbm}(
  object,
  coefficients = coefficients,
  basic.stats = NULL,
  sup.stats = NULL,
  sup.args = NULL,
  fisher.matrix = TRUE,
  sandwich = FALSE,
  R2.method = c("KL", "Nagelkerke", "COR"),
  cor.method = "pearson",
  R = 999,
  seed = NULL,
  sim = "parametric",
  stype = "i",
  simple = FALSE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("boot.ncpus", 1L),
  cl = NULL,
  ...
)
}
\arguments{
\item{object}{an object of class \code{"msbm"}, typically returned
by \link[msbreg]{msbreg}.}

\item{coefficients}{numeric vector, model parameters to generate data
for parametric bootstrap (when \code{sim = 'parametric'}).
The default is the \code{$coefficients} component of \code{object}.}

\item{basic.stats}{character vector indicating basic (pre-defined)
statistics to include in the set of bootstrapped statistics, in addition
to the vector component \code{$coefficients} of \code{"msbm"} fits.
The default (\code{NULL}) means
none. Currently, \code{basic.stats} can include any or many of:

\describe{
\item{"\code{r.squared}"}{ to include some pseudo-\eqn{R^2} measures;}
\item{"\code{alpha}"}{ to include the \code{$alpha} component of
\code{summary(object)};}
\item{"\code{lambda}"}{ to include the \code{$lambda} component of
\code{summary(object)};}
\item{"\code{alpha.lambda}"}{ to include the \code{$alpha.lambda} component
of \code{summary(object)};}
\item{"\code{mu}"}{ to include the \code{$mu} component
of \code{summary(object)};}
\item{"\code{se.fit}"}{ to include estimated standard errors for estimated
model parameters and quantities such as \code{alpha}, \code{lambda},
\code{alpha.lambda}, and \code{mu} (standard errors are useful for
instance for building a Studentized bootstrap confidence interval,
see \link[boot]{boot.ci}).}
}}

\item{sup.stats}{a function, or a character naming a function to compute
some interest statistics from the \code{"msbm"} class input.
If \code{sup.args} is \code{NULL}, the function \code{sup.stats} must
take one argument and return a numeric vector. Otherwise, \code{sup.stats}
must take two arguments and return a numeric vector.}

\item{sup.args}{(list of) supplemental argument(s) for the function
\code{sup.stats}. If supplied (and not \code{NULL}), \code{sup.args}
is passed as a second argument to \code{sup.stats} (an object of the
same shape as \code{object} being the first argument).}

\item{fisher.matrix}{logical, should the Fisher (expected) information
matrix be used to obtain standard errors? Defaults to  \code{TRUE}.
The alternative, \code{fisher.matrix = FALSE}, is the observed
information matrix.}

\item{sandwich}{logical, should the sandwich variance-covariance
estimator be considered for standard error calculation?
Defaults to \code{FALSE}.}

\item{R2.method}{character, indicates the pseudo-\eqn{R^2} statistic
to include into the bootstrapped statistics. Only used when
\code{basic.stats} includes \code{"r.squared"}. See argument \code{method}
of \link[msbreg]{rsquared} for possible values of \code{R2.method}.}

\item{cor.method}{character indicating which correlation coefficient
to consider (only used when \code{basic.stats} includes \code{"r.squared"},
and \code{R2.method = "COR"}).}

\item{R, sim, stype, simple, parallel, ncpus, cl}{named arguments passed to \link[boot]{boot}.}

\item{seed}{a single value (random seed), interpreted as an integer,
or \code{NULL}. It is passed to \link{set.seed} when not \code{NULL}.
Same use as for \link[msbreg]{bootfit} (see \strong{Details} therein).}

\item{...}{further named arguments passed to or from other methods.
Currently, the method takes and passes named arguments \code{strata},
\code{L}, \code{m}, and \code{weights} to \link[boot]{boot}
(see documentation therein).}
}
\value{
An object inheriting from class \code{"boot"} (as defined
from package \code{boot}). See \link[msbreg]{bootfit}.
}
\description{
This is a method of \link[msbreg]{bootfit} for class \code{"msbm"} objects.
It bootstraps a Multistage Binomial (MSB) model fit and returns an object
inheriting from class "\link[boot]{boot}".
}
\details{
This \link[msbreg]{bootfit} method wraps \link[boot]{boot} to specifically
handle \code{"msbm"} class objects. When \code{sim = 'parametric'}
(\emph{parametric bootstrap}), the response variable in \code{object} is
resampled from a binomial distribution with success probability
determined by the estimated model parameters in \code{object}, while
re-using covariates in the original data used to fit the model.
For \emph{non-parametric bootstrap}, both the response and the covariates are
resampled from the original data.

The argument \code{sup.stats} is intended to allow more flexibility
in the specification of statistics: any quantity of interest can be
extracted from the fit \code{object} to obtain its bootstrap
distribution.

On multicore plateformes, consider using arguments \code{parallel},
\code{ncpus}, and \code{cl} to allow parallel computations which can
be faster. This is currently based on the \code{R} package \code{parallel}
or \code{snow} (see \link[boot]{boot}).
}
\examples{
##* Load packages
require(boot)
require(msbreg)

##* Infertility data
data ("infert", package = "datasets")

## Logistic regression fit to the infert data
GLMres <- msbreg (case ~ spontaneous,
                  lambda.formula = ~ 0, # maximum success probability set to 1
                  data = infert, criterion = "ML")

summary (GLMres)

## MSB model fit
MSBres <- msbreg (case ~ spontaneous,
                  lambda.formula = ~ 1, # unknown constant maximum success probability
                  start = c(GLMres$coefficients, 1),
                  data = infert, criterion = "ML")

sumMSBres <- summary (MSBres)
sumMSBres

AIC (GLMres, MSBres)
rsquared(GLMres, MSBres, adjust.size = TRUE)

#* By the larger AIC (as compared with the simple GLM)
# and the not larger adjusted r-squared, the additional
# parameter lambda does not seem justified
#* Is adding 'lambda' overfitting?

# Wald confidence interval (normality assumed at logit scale)
plogis(sumMSBres$coefficients[3,1] +
       c(-1, 1) * sumMSBres$coefficients[3,2] * qnorm(0.975))

# This interval is useless (too wide)
# We could boostrap the fit
\dontrun{
set.seed(167)
bMSBres = bootfit(MSBres, R = 999) # (takes about 3 minutes)

# Build bootstrap percentile confidence interval for lambda
boot.ci (bMSBres, index = 3, conf = 0.95, type = "perc",
         h = MSBres$link$linkinv)

# Intervals :
# Level     Percentile
#   95\%   [0.5321,  1.0000]

# The data can only be used to infer that lambda is
# most likely above 0.5.

# Estimating lambda is indeed overfitting,
# but reason advocates lambda = 1 against any
# other value above 0.5.

# Based on a profiled likelihood graphic,
# we can use the ML estimate while keeping the variability in mind
 profile.logLike <- function(lambda) {
   f0 <- function(lambda0) {
     data <- infert
     data$eta.lambda <- qlogis(lambda0)
     res <- msbreg (case ~ spontaneous,
                    lambda.formula = ~ offset(eta.lambda) + 0,
                    start = GLMres$coefficients,
                    data = data, criterion = "ML",
                    frame = TRUE)
     return(logLik(res)[1])
   }
 sapply(lambda, f0)
}

# (takes about 35 seconds)
curve(profile.logLike, from = 0.75, to = 0.95,
      n = 500, xlab = expression(lambda), ylab = "logLik")

# Of course, we can look for additional
# predictor(s) in the 'infert' dataset
}

# Simulated data example
data("test1data")

# Fit a MSB model
msbfit = msbreg (cbind(y, Total - y) ~ x1 + offset(off1) | x2,
                 control = list(criterion = "MLJ"),
                 data = test1data)
summary(msbfit)

\dontrun{
# Bootstrap the model fit (takes about 20 minutes)
bootmsbfit <- bootfit (msbfit, R = 999)
bootmsbfit

# PARAMETRIC BOOTSTRAP
#
# Call:
# bootfit(object = msbfit, R = 999)
#
# Bootstrap Statistics :
#         original        bias     std. error
# t1*     2.739186  -0.003356267   0.11203355
# t2*    -1.831737   0.002217852   0.06162532
# t3*     3.273386   0.008053197   0.11695760
# t4*    -2.100589  -0.002623420   0.04072792
# t5*     1.857221   0.009574422   0.15732079
# t6*  -703.325885 -19.358176807  17.37753997
# t7*   428.224752  28.138879811  28.26254848
# t8* 20477.886114  38.158915179 275.78735080

# Build bootstrap percentile confidence interval for the slope of 'x1'
boot.ci (bootmsbfit, index = 2, conf = 0.95, type = "perc")

#
# BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
# Based on 999 bootstrap replicates
#
# CALL :
# boot.ci(boot.out = bootmsbfit, conf = 0.95, type = "perc", index = 2)
#
# Intervals :
# Level     Percentile
# 95\%   (-1.953, -1.719 )
# Calculations and Intervals on Original Scale

# Build bootstrap percentile confidence intervals for 'lambda'
# (using the inverse link function to map logit(lambda) to lambda)
boot.ci (bootmsbfit, index = 5, conf = 0.95, type = "perc",
         h = msbfit$link$linkinv)

# BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
# Based on 999 bootstrap replicates
#
# CALL :
# boot.ci(boot.out = bootmsbfit, conf = 0.95, type = "perc", index = 5,
#         h = msbfit$link$linkinv)
#
# Intervals :
# Level     Percentile
# 95\%   ( 0.8277,  0.9017 )
# Calculations and Intervals on  Transformed Scale
#
}

}
\seealso{
\link[msbreg]{bootfit} for the default method.
Also see \link[msbreg]{MCmsbm} for Monte Carlo simulations
with possibly many multistage binomial models.
}
