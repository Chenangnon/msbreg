% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimselfstart.R
\name{optim.selfstart}
\alias{optim.selfstart}
\title{Self-starting Multivariable Optimization}
\usage{
optim.selfstart(
  npars = NCOL(pars),
  design = c("bbd", "ccd", "one"),
  star.points = c("rotatable", "orthogonal", "spherical"),
  inf = 7,
  pars = NULL,
  fn,
  gr = NULL,
  ...,
  method = c("Nelder-Mead", "CG", "BFGS", "L-BFGS-B", "SANN", "Brent", "port", "nlminb"),
  lower = -Inf,
  upper = Inf,
  control = list(),
  hessian = FALSE,
  chunk.size = NULL,
  cl = parallel::getDefaultCluster(),
  LB = FALSE
)
}
\arguments{
\item{npars}{numeric (scalar), number of parameters taken by the function
to be optimized (\code{fn}).}

\item{design}{character, one of \code{"bbd"} (use all points from a BBD
as starting parameter values), \code{"ccd"} (use all points from a CCD
as starting values), and \code{"one"} (use one starting point: the
center of the sample space).}

\item{star.points}{character indicating how axial points
(start points) are introduced in the design. One of \code{"rotatable"},
\code{"orthogonal"}, \code{"spherical"}.}

\item{inf}{numeric (scalar), limits of the sample space to substitute to
any \code{Inf} in \code{lower} or \code{upper}. This substitution is only
used to generate the starting values, the supplied \code{lower} or
\code{upper} arguments are passed unchanged to \link[stats]{nlminb}
or \link[stats]{optim}.}

\item{pars}{optional matrix of initial values (rows of \code{pars})
for the parameters to be optimized over. If \code{pars} is supplied,
all previous arguments are ignored.}

\item{fn, gr, ..., method, lower, upper, control, hessian}{arguments passed
to \link[stats]{nlminb} or \link[stats]{optim}.}

\item{chunk.size, cl}{arguments passed to \link[parallel]{parLapply}.}

\item{LB}{logical, should \link[parallel]{parLapplyLB} be used instead
of \link[parallel]{parLapply}?}
}
\value{
a list as returned by \link[stats]{optim}, with the following
additional elements:

\item{\code{starts}}{ matrix of used starting parameter values;}

\item{\code{table}}{ matrix of optimization results for each starting
point: the objective function value (first column), the optimal vector
of parameters, and the numbers of function and gradient evaluations;}

\item{\code{k}}{ the number of the row (in \code{starts}) of an
optimal starting parameter, that is, starting parameter value which
led to the optimal objective function value.}
}
\description{
Generate points from a specified design to start
a multivariable optimization with \link[stats]{nlminb} or \link[stats]{optim}.
Starting values can be requested from a \code{Central-Composite Design}
(CCD) or a \code{Box-Behnken Design} (BBD) over the sample space.
}
\details{
Note that arguments after ... must be matched exactly.

The function aims to self-start the General-purpose Optimization
routine \link[stats]{nlminb} or \link[stats]{optim}. This is mostly
useful for non regular/smooth objective function \code{fn} with the
simplex method \code{method = "Nelder-Mead"}. Trading-off time for
precision, \code{optim.selfstart} increases the chance of finding
the global optimum of the objective by starting from a wide range of
points in the sample space, depending on the argument \code{design}.

The argument \code{pars} is the matrix counterpart of the
argument \code{par} of \link[stats]{optim} to allow more flexibility:
a user-determined set of starting points can be supplied.

In all cases, \link[stats]{nlminb} or \link[stats]{optim} is
repeatedly called with each starting value, and the best optimization
result is returned.

On multicore plateformes, consider using argument \code{chunk.size},
\code{cl} and \code{LB} o allow parallel computations which can be faster.
This is currently based on the \code{R} package \code{parallel}.
}
\examples{
require(graphics)


#* Example taken from optim help page:
#  Modified Rosenbrock Banana function
fr <- function(x) {
 x1 <- x[1]
 x2 <- x[2]
 100 * (x2 - floor(x1)*x1)^2 + (1 - floor(x1))^2
}

# The minimum value of fr is zero, attained at x = c(a, a)
# for any a in the semi-open [1, 2).

# As expected derivative based method fails to find the minimum value 0
# starting from x = c(-1.2, 1) as on optim help page
optim(par = c(-1.2,1), fn = fr, method = "BFGS")[c('value', 'par')]

 # But the simplex method also fails
optim(par = c(-1.2,1), fn = fr, method = "Nelder-Mead")[c('value', 'par')]

# Try multiple starting values with the simplex method
optim.selfstart(2, fn = fr, method = "Nelder-Mead",
                design = 'ccd')[c('value', 'par')]


}
\seealso{
\link[stats]{optim} for the workhorse routine.
}
